#use <conio>
#use <string>

int GROW_CAPACITY (int oldCapacity){
  return ((oldCapacity) < 8 ? 8 : (oldCapacity) + oldCapacity / 2);
}

int hash(int index, int arrayLength)
    //@requires index >= 0;
    //@ensures \result >= 0 && \result < arrayLength;
{
    index = ((index >> 16) ^ index) * 0x45d9f3b;
    index = ((index >> 16) ^ index) * 0x45d9f3b;
    index = (index >> 16) ^ index;
    return index % arrayLength;
}

void initOwnedFields(OwnedFields* fields, int * instanceCounter){
  fields->instanceCounter = instanceCounter;
  int oldCapacity = 0;
  fields->capacity = GROW_CAPACITY(oldCapacity);
  fields->contents = alloc_array(FieldArray*, fields->capacity);

  for(int i = 0; i < fields->capacity; i += 1){
    fields->contents[i] = NULL;
  }
}

void grow(OwnedFields* fields)
  //@requires fields != NULL;
  //@ensures fields != NULL && fields->capacity > fields->length;
{
  int oldCapacity = fields->capacity;
  fields->capacity = GROW_CAPACITY(oldCapacity);
  FieldArray*[] newContents = alloc_array(FieldArray*, fields->capacity);
  for(int i = 0; i<oldCapacity; i += 1){
    if(fields->contents[i] != NULL && !fields->contents[i]->deleted){
        int _id = fields->contents[i]->_id;
        int newIndex = hash(_id, fields->capacity);
        newContents[newIndex] = fields->contents[i];
    }
  }
  fields->contents = newContents;
}

FieldArray* find(OwnedFields* fields, int _id){
  int index = hash(_id, fields->capacity);
  if(fields->contents[index] != NULL && !fields->contents[index]->deleted){
    return fields->contents[index];
  }else{
    return NULL;
  }
}

FieldArray * newFieldArray(OwnedFields * fields, int _id, int numFields, bool accAll)
  //@requires fields != NULL && _id >= 0 && numFields > 0;
  //@ensures fields != NULL && fields->capacity > fields->length;
{
  if(fields->length > (fields->capacity * (5/6))) grow(fields);

  int fieldIndex = hash(_id, fields->capacity);
  while(fields->contents[fieldIndex] != NULL) fieldIndex += 1;

  FieldArray * array = alloc(FieldArray);
  fields->contents[fieldIndex] = array;
  fields->length += 1;

  array->contents = alloc_array(bool, numFields);
  array->length = numFields;
  array->_id = _id;
  array->deleted = false;

  for(int i = 0; i<array->length; i += 1){
    array->contents[i] = accAll;
  }
  if(accAll) array->numAccessible = array->length;
  return fields->contents[fieldIndex];
}

int addStructAccess(OwnedFields * fields, int numFields){
    newFieldArray(fields, *fields->instanceCounter, numFields, true);
    *(fields->instanceCounter) += 1;
    return *(fields->instanceCounter) - 1;
}

void addAccess(OwnedFields * fields, int _id, int numFields, int fieldIndex){
  FieldArray * array = find(fields, _id);
  if(array != NULL){
    array->contents[fieldIndex] = true;
  }else{
    array = newFieldArray(fields, _id, numFields, false);
    array->contents[fieldIndex] = true;
  }
  array->numAccessible += 1;
}


void assertAcc(OwnedFields* fields, int _id, int fieldIndex, string errorMessage){
    FieldArray* toCheck = find(fields, _id);
    if(toCheck != NULL){
        if(fieldIndex >= toCheck->length){
            error("[INTERNAL] Field index exceeds maximum for the given struct.\n");
        }else if(toCheck->contents[fieldIndex]){
            return;
        }
    }
    error(errorMessage);
}

void assertDisjointAcc(OwnedFields* static, OwnedFields* dynamic, int _id, int fieldIndex, string errorMessage){
    FieldArray* toCheck = find(static, _id);
    if(toCheck != NULL && toCheck->length <= fieldIndex) error("[INTERNAL] Field index exceeds maximum for the static OwnedFields struct.\n");
    if(toCheck == NULL || !toCheck->contents[fieldIndex]){
        assertAcc(dynamic, _id, fieldIndex, errorMessage);
    }else{
        error(errorMessage);
    }
}

void join(OwnedFields* target, OwnedFields* source){
    if(source != NULL && target != NULL){
        for(int i = 0; i<source->capacity; i += 1){
            FieldArray* currFields = source->contents[i];
            if(currFields != NULL){
                for(int j = 0; j< currFields->length; j += 1){
                    addAccess(target, currFields->_id, currFields->length, j);
                }
            }
        }
    }
}

void disjoin(OwnedFields* target, OwnedFields* source){
    if(source != NULL && target != NULL){
        for(int i = 0; i<source->capacity; i += 1){
            FieldArray* currFields = source->contents[i];
            if(currFields != NULL){
                FieldArray* inTarget = find(target, currFields->_id);
                if(inTarget != NULL){
                    if(currFields->numAccessible == currFields->length && inTarget->numAccessible == inTarget->length) {
                        inTarget->deleted = true;
                    }else{
                        for(int j = 0; j<currFields->length; j += 1){
                            if(inTarget->contents[j] && currFields->contents[j]){
                                inTarget->contents[j] = false;
                                inTarget->numAccessible -= 1;
                            }
                        }
                        if(inTarget->numAccessible == 0){
                            inTarget->deleted = true;
                        }
                    }
                }
            }
        }
    }
}