#use "field_access.h0"
#use <conio>
#use <string>

int GROW_CAPACITY (int oldCapacity){
  return ((oldCapacity) < 8 ? 8 : (oldCapacity) + oldCapacity / 2);
}

int hash(int index, int arrayLength){
    index = ((index >> 16) ^ index) * 0x45d9f3b;
    index = ((index >> 16) ^ index) * 0x45d9f3b;
    index = (index >> 16) ^ index;
    return index % arrayLength;
}

void initOwnedFields(OwnedFields* fields, int * instanceCounter){
  fields->instanceCounter = instanceCounter;
  int oldCapacity = 0;
  fields->capacity = GROW_CAPACITY(oldCapacity);
  fields->contents = alloc_array(FieldArray*, fields->capacity);

  for(int i = 0; i < fields->capacity; i += 1){
    fields->contents[i] = NULL;
  }
}

void grow(OwnedFields* fields){
  int oldCapacity = fields->capacity;
  fields->capacity = GROW_CAPACITY(oldCapacity);
  FieldArray*[] newContents = alloc_array(FieldArray*, fields->capacity);
  for(int i = 0; i<oldCapacity; i += 1){
    if(fields->contents[i] != NULL){
        int _id = fields->contents[i]->_id;
        int newIndex = hash(_id, fields->capacity);
        newContents[newIndex] = fields->contents[i];
    }
  }
  fields->contents = newContents;
}

FieldArray* find(OwnedFields* fields, int _id){
  int index = hash(_id, fields->capacity);
  return fields->contents[index];
}

FieldArray * newFieldArray(OwnedFields * fields, int _id, int numFields, bool accAll){
  if(fields->length > (fields->capacity * (5/6))) grow(fields);

  int fieldIndex = hash(_id, fields->capacity);
  while(fields->contents[fieldIndex] != NULL && !fields->contents[fieldIndex]->deleted) fieldIndex += 1;

  FieldArray * array = alloc(FieldArray);
  fields->contents[fieldIndex] = array;
  fields->length += 1;

  array->contents = alloc_array(bool, numFields);
  array->length = numFields;
  array->deleted = false;
  array->_id = _id;

  for(int i = 0; i<array->length; i += 1){
    array->contents[i] = accAll;
  }

  return fields->contents[fieldIndex];
}

void debugOwnedFields(OwnedFields* fields, string name){
    print("---[ ");
    print(name);
    print(" ]---\n");
    print("* Num. of structs: ");
    printint(fields->length);
    print("\n");
    print("* Capacity: ");
    printint(fields->capacity);
    print("\n");
    print("[");
    if(fields->capacity > 0){
        if(fields->contents[0] != NULL){
            printint(fields->contents[0]->_id);
        }else{
            print("NULL");
        }
        for(int i = 1; i < fields->capacity; i+=1){
            print(", ");
            if(fields->contents[i] != NULL){
                printint(fields->contents[i]->_id);
            }else{
                print("NULL");
            }
        }
    }
    print("]\n");
}

int addStructAccess(OwnedFields * fields, int numFields){
    newFieldArray(fields, *fields->instanceCounter, numFields, true);
    *(fields->instanceCounter) += 1;
    return *(fields->instanceCounter) - 1;
}

void addAccess(OwnedFields * fields, int _id, int numFields, int fieldIndex){
  FieldArray * array = find(fields, _id);
  if(array != NULL){
    array->contents[fieldIndex] = true;
  }else{
    array = newFieldArray(fields, _id, numFields, false);
    array->contents[fieldIndex] = true;
  }
}

void assertOverlappingAcc(OwnedFields* static, OwnedFields* all, int _id, int fieldIndex){
    FieldArray* existsStatically = find(static, _id);
    if(existsStatically == NULL || existsStatically->deleted || !existsStatically->contents[fieldIndex]){
        assertDisjointAcc(all, _id, fieldIndex);
    }else{
        error();
    }
}
void assertDisjointAcc(OwnedFields* all, int _id, int fieldIndex){
    FieldArray* toCheck = find(fields, _id);
    if(toCheck != NULL && !toCheck->deleted){
        if(fieldIndex >= toCheck->length || !toCheck->contents[fieldIndex]){
            error();
        }
    }else{
        error();
    }
}

void join(OwnedFields* target, OwnedFields* source){
    for(int i = 0; i<source->capacity; i += 1){
        FieldArray* currFields = source->contents[i];
        if(currFields != NULL){
            for(int j = 0; j< currFields->length; j += 1){
                addAccess(target, currFields->_id, currFields->length, j);
            }
        }
    }
}

void disjoin(OwnedFields* joined, OwnedFields* source){
    for(int i = 0; i<source->capacity; i += 1){
        FieldArray* currFields = source->contents[i];
        if(currFields != NULL){
            int hashIndex = hash(currFields->_id, joined->capacity);
            FieldArray* fieldsToDelete = joined->contents[hashIndex];
            while(fieldsToDelete != NULL && fieldsToDelete->_id != currFields->_id){
                hashIndex += 1;
                fieldsToDelete = joined->contents[hashIndex];
            }
            if(fieldsToDelete != NULL){
               joined->contents[hashIndex]->deleted = true;
               joined->length -= 1;
            }else{
                error("Two OwnedFields were disjoined that had never been joined, or that somehow lost access to one or more field permissions.");
            }
        }
    }
}