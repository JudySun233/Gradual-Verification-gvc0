/*
p.bst.6.pred.pred_inst.117.140
m.tree_remove_lemma.2.post.pred_inst.88.104
m.tree_contains_helper.3.fold.pred_inst.28.36
m.tree_min_lemma.1.pre.bool.68.83
m.tree_min_helper.3.fold.pred_inst.66.81
m.tree_min.1.pre.bool.55.67
m.tree_remove_lemma_left2.3.fold.pred_inst.102.120
m.tree_remove_lemma_max.3.fold.pred_inst.106.125
p.bst.6.pred.acc.117.143
m.tree_remove_lemma_left2.2.post.pred_inst.98.116
m.tree_main_lemma_bst.4.unfold.pred_inst.36.44
m.tree_min_helper.2.post.bool.60.74
m.create_tree_helper.1.pre.bool.3.5
m.tree_remove.4.unfold.pred_inst.74.90
m.tree_max_helper.3.fold.pred_inst.49.60
m.tree_remove_helper.3.fold.pred_inst.78.94
p.bstRemove.6.pred.acc.118.154
m.tree_remove_helper.3.fold.pred_inst.86.102
p.tree.6.pred.pred_inst.119.155
m.tree_remove_lemma_right.2.post.pred_inst.112.133
m.create_tree_helper.3.fold.pred_inst.5.7
m.tree_remove_helper.3.fold.pred_inst.85.101
m.tree_remove_lemma_right.3.fold.pred_inst.114.135
m.tree_remove_lemma_left2.3.fold.pred_inst.100.118
m.tree_remove_lemma_min.3.fold.pred_inst.110.130
m.tree_min_helper.3.fold.pred_inst.63.78
m.tree_contains.2.post.pred_inst.21.29
m.main.5.inv.bool.11.15
m.tree_min_lemma.3.fold.pred_inst.71.87
m.create_tree_helper.3.fold.pred_inst.6.8
m.tree_contains_helper.1.pre.pred_inst.24.32
m.tree_max_helper.4.unfold.pred_inst.44.55
m.tree_remove_helper.4.unfold.pred_inst.83.99
p.bstRemove.6.pred.bool.118.151
m.tree_contains_helper.2.post.pred_inst.25.33
m.tree_remove_helper.0.assert.bool.84.100
m.tree_max_helper.3.fold.pred_inst.50.61
m.tree_max.3.fold.pred_inst.41.50
m.create_tree_helper.1.pre.bool.3.4
p.bst.6.pred.pred_inst.117.139
m.tree_remove_lemma_left.3.fold.pred_inst.96.113
m.tree_max_helper.0.assert.bool.48.59
m.tree_main_lemma.2.post.pred_inst.31.39
m.tree_min_helper.1.pre.pred_inst.59.73
m.tree_min.3.fold.pred_inst.58.71
p.bstRemove.6.pred.bool.118.146
p.bstRemove.6.pred.bool.118.149
m.tree_remove_lemma_min.4.unfold.pred_inst.109.129
m.tree_contains.1.pre.pred_inst.20.28
m.tree_remove_lemma_left2.4.unfold.pred_inst.99.117
m.tree_remove_helper.1.pre.pred_inst.76.92
m.tree_min_lemma.1.pre.pred_inst.68.84
m.tree_main_lemma.1.pre.pred_inst.30.38
m.tree_remove_lemma_max.2.post.pred_inst.104.123
m.tree_remove_lemma_right.4.unfold.pred_inst.113.134
m.tree_max_helper.3.fold.pred_inst.46.57
m.tree_min_helper.3.fold.pred_inst.62.77
m.tree_max.1.pre.bool.38.46
m.tree_main_lemma_bst.2.post.pred_inst.35.43
m.tree_max_lemma.2.post.pred_inst.52.64
m.tree_max_helper.2.post.bool.43.53
m.tree_min_lemma.2.post.pred_inst.69.85
m.create_tree.2.post.pred_inst.1.2
m.tree_remove_lemma_max.1.pre.pred_inst.103.122
m.tree_remove_lemma_right.1.pre.bool.111.131
m.tree_remove_helper.2.post.pred_inst.77.93
m.tree_remove.1.pre.pred_inst.72.88
m.tree_max_helper.3.fold.pred_inst.45.56
m.tree_max.4.unfold.pred_inst.40.49
m.tree_main_lemma_bst.1.pre.pred_inst.34.42
p.bst.6.pred.bool.117.141
m.tree_remove_helper.3.fold.pred_inst.80.96
m.tree_add_helper.2.post.pred_inst.17.25
m.tree_add.2.post.pred_inst.13.19
m.tree_min_helper.4.unfold.pred_inst.61.76
m.tree_remove_lemma_right.3.fold.pred_inst.115.136
m.tree_remove_lemma.3.fold.pred_inst.90.106
m.tree_add.1.pre.bool.12.17
m.tree_add_helper.4.unfold.pred_inst.18.26
m.tree_remove_lemma.4.unfold.pred_inst.89.105
m.tree_max_helper.2.post.pred_inst.43.54
m.tree_remove_lemma_left2.1.pre.pred_inst.97.115
m.tree_add.1.pre.pred_inst.12.18
m.create_tree.1.pre.bool.0.1
m.main.5.inv.bool.11.14
p.bstRemove.6.pred.pred_inst.118.147
m.tree_add_helper.3.fold.pred_inst.19.27
m.tree_contains_helper.3.fold.pred_inst.29.37
m.tree_remove_helper.3.fold.pred_inst.82.98
m.tree_contains.3.fold.pred_inst.23.31
p.bst.6.pred.acc.117.145
m.tree_remove_lemma_left.3.fold.pred_inst.95.112
m.tree_max.1.pre.pred_inst.38.47
m.create_tree.2.post.imp.1.-1
m.tree_remove_lemma_right.1.pre.pred_inst.111.132
m.tree_add_helper.1.pre.bool.16.23
m.tree_remove_lemma_left.2.post.pred_inst.92.109
m.main.2.post.bool.9.11
m.tree_add.3.fold.pred_inst.15.21
m.tree_contains_helper.4.unfold.pred_inst.26.34
m.create_tree_helper.2.post.pred_inst.4.6
m.tree_remove_helper.4.unfold.pred_inst.79.95
m.tree_max_lemma.1.pre.bool.51.62
m.tree_add_helper.1.pre.bool.16.22
m.tree_remove_lemma_left.4.unfold.pred_inst.93.110
p.treeRemove.6.pred.pred_inst.120.156
p.bstRemove.6.pred.bool.118.150
m.tree_remove_lemma_max.4.unfold.pred_inst.105.124
m.main.1.pre.bool.8.10
m.tree_min.1.pre.pred_inst.55.68
m.tree_max_lemma.4.unfold.pred_inst.53.65
m.tree_remove_lemma.1.pre.pred_inst.87.103
m.tree_remove.3.fold.pred_inst.75.91
m.tree_add.1.pre.bool.12.16
m.tree_max_helper.1.pre.bool.42.51
m.tree_main_lemma.4.unfold.pred_inst.32.40
m.create_tree.3.fold.pred_inst.2.3
m.tree_max_helper.4.unfold.pred_inst.47.58
m.tree_main_lemma.3.fold.pred_inst.33.41
m.tree_min.2.post.pred_inst.56.69
p.bstRemove.6.pred.pred_inst.118.148
m.tree_max_lemma.1.pre.pred_inst.51.63
m.tree_contains.4.unfold.pred_inst.22.30
m.tree_remove_helper.3.fold.pred_inst.81.97
m.tree_contains_helper.3.fold.pred_inst.27.35
m.tree_min_helper.2.post.pred_inst.60.75
m.tree_max.2.post.pred_inst.39.48
p.bst.6.pred.acc.117.144
m.tree_remove_lemma_left.1.pre.bool.91.107
m.tree_remove_lemma_left2.1.pre.bool.97.114
m.tree_remove_lemma_max.1.pre.bool.103.121
m.tree_add_helper.1.pre.pred_inst.16.24
m.tree_min_helper.3.fold.pred_inst.67.82
m.create_tree.1.pre.bool.0.0
m.tree_remove_lemma_left.1.pre.pred_inst.91.108
m.tree_remove_lemma_right.3.fold.pred_inst.116.137
m.tree_add.4.unfold.pred_inst.14.20
p.bstRemove.6.pred.acc.118.153
m.tree_main_lemma_bst.3.fold.pred_inst.37.45
m.tree_remove_lemma_min.2.post.pred_inst.108.128
m.tree_min_helper.0.assert.bool.65.80
p.bstRemove.6.pred.acc.118.152
m.tree_max_helper.1.pre.pred_inst.42.52
p.bst.6.pred.bool.117.142
m.create_tree_helper.3.fold.pred_inst.7.9
m.tree_min.4.unfold.pred_inst.57.70
m.main.5.inv.bool.10.12
m.tree_remove_lemma_min.1.pre.bool.107.126
m.main.5.inv.bool.10.13
m.tree_max_lemma.3.fold.pred_inst.54.66
m.tree_min_helper.1.pre.bool.59.72
m.tree_min_lemma.4.unfold.pred_inst.70.86
m.tree_remove.2.post.pred_inst.73.89
p.bst.6.pred.bool.117.138
*/
#use <runtime>
#use <stress>
struct Node;

struct Node
{
  int val;
  struct Node* left;
  struct Node* right;
  int _id;
};

void add_bst(struct Node* root, int min, int max, struct OwnedFields* _ownedFields);
void add_bstRemove(struct Node* root, int x, int min, int max, struct OwnedFields* _ownedFields);
void add_tree(struct Node* root, struct OwnedFields* _ownedFields);
void add_treeRemove(struct Node* root, int x, struct OwnedFields* _ownedFields);
void bst(struct Node* root, int min, int max, struct OwnedFields* _ownedFields);
void bstRemove(struct Node* root, int x, int min, int max, struct OwnedFields* _ownedFields);
struct Node* create_tree(int val, struct OwnedFields* _ownedFields);
struct Node* create_tree_helper(int val, int min, int max, int* _instanceCounter);
int main();
void remove_bst(struct Node* root, int min, int max, struct OwnedFields* _ownedFields);
void remove_bstRemove(struct Node* root, int x, int min, int max, struct OwnedFields* _ownedFields);
void remove_tree(struct Node* root, struct OwnedFields* _ownedFields);
void remove_treeRemove(struct Node* root, int x, struct OwnedFields* _ownedFields);
void sep_bst(struct Node* root, int min, int max, struct OwnedFields* _ownedFields);
void sep_bstRemove(struct Node* root, int x, int min, int max, struct OwnedFields* _ownedFields);
struct Node* tree_add(struct Node* root, int x, int* _instanceCounter);
struct Node* tree_add_helper(struct Node* root, int x, int min, int max, int* _instanceCounter);
bool tree_contains(struct Node* root, int x, struct OwnedFields* _ownedFields);
bool tree_contains_helper(struct Node* root, int x, int min, int max, int* _instanceCounter);
void tree_main_lemma(struct Node* root, int x, int* _instanceCounter);
void tree_main_lemma_bst(struct Node* root, int x, int min, int max, int* _instanceCounter);
int tree_max(struct Node* root, struct OwnedFields* _ownedFields);
int tree_max_helper(struct Node* root, int min, int max, int* _instanceCounter);
void tree_max_lemma(struct Node* root, int newMax, int min, int max, struct OwnedFields* _ownedFields);
int tree_min(struct Node* root, struct OwnedFields* _ownedFields);
int tree_min_helper(struct Node* root, int min, int max, struct OwnedFields* _ownedFields);
void tree_min_lemma(struct Node* root, int newMin, int min, int max, struct OwnedFields* _ownedFields);
struct Node* tree_remove(struct Node* root, int x, int* _instanceCounter);
struct Node* tree_remove_helper(struct Node* root, int x, int min, int max, int* _instanceCounter);
void tree_remove_lemma(struct Node* root, int min, int max, int* _instanceCounter);
void tree_remove_lemma_left(struct Node* l, int x, int min, int max, struct OwnedFields* _ownedFields);
void tree_remove_lemma_left2(struct Node* l, int newX, int x, int min, int max, struct OwnedFields* _ownedFields);
void tree_remove_lemma_max(struct Node* root, int x, int newMax, int min, int max, int* _instanceCounter);
void tree_remove_lemma_min(struct Node* root, int x, int newMin, int min, int max, struct OwnedFields* _ownedFields);
void tree_remove_lemma_right(struct Node* r, int x, int min, int max, int* _instanceCounter);

void add_bst(struct Node* root, int min, int max, struct OwnedFields* _ownedFields)
{
  if (!(root == NULL))
  {
    addAcc(_ownedFields, root->_id, 4, 1);
    addAcc(_ownedFields, root->_id, 4, 2);
    addAcc(_ownedFields, root->_id, 4, 0);
    add_bst(root->left, min, root->val - 1, _ownedFields);
    add_bst(root->right, root->val + 1, max, _ownedFields);
  }
}

void add_bstRemove(struct Node* root, int x, int min, int max, struct OwnedFields* _ownedFields)
{
  if (!(root == NULL))
  {
    addAcc(_ownedFields, root->_id, 4, 1);
    addAcc(_ownedFields, root->_id, 4, 2);
    addAcc(_ownedFields, root->_id, 4, 0);
    add_bstRemove(root->left, x, min, root->val - 1, _ownedFields);
    add_bstRemove(root->right, x, root->val + 1, max, _ownedFields);
  }
}

void add_tree(struct Node* root, struct OwnedFields* _ownedFields)
{
  add_bst(root, -2147483647, 2147483647, _ownedFields);
}

void add_treeRemove(struct Node* root, int x, struct OwnedFields* _ownedFields)
{
  add_bstRemove(root, x, -2147483647, 2147483647, _ownedFields);
}

void bst(struct Node* root, int min, int max, struct OwnedFields* _ownedFields)
{
  if (root == NULL)
  {
    assert(true);
  }
  else
  {
    assertAcc(_ownedFields, root != NULL ? root->_id : -1, 1, "Field access runtime check failed for struct Node.left");
    assertAcc(_ownedFields, root != NULL ? root->_id : -1, 2, "Field access runtime check failed for struct Node.right");
    assertAcc(_ownedFields, root != NULL ? root->_id : -1, 0, "Field access runtime check failed for struct Node.val");
    assert(root->val >= min);
    assert(root->val <= max);
    bst(root->left, min, root->val - 1, _ownedFields);
    bst(root->right, root->val + 1, max, _ownedFields);
  }
}

void bstRemove(struct Node* root, int x, int min, int max, struct OwnedFields* _ownedFields)
{
  if (root == NULL)
  {
    assert(true);
  }
  else
  {
    assertAcc(_ownedFields, root != NULL ? root->_id : -1, 1, "Field access runtime check failed for struct Node.left");
    assertAcc(_ownedFields, root != NULL ? root->_id : -1, 2, "Field access runtime check failed for struct Node.right");
    assertAcc(_ownedFields, root != NULL ? root->_id : -1, 0, "Field access runtime check failed for struct Node.val");
    assert(root->val >= min);
    assert(root->val <= max);
    assert(root->val != x);
    bstRemove(root->left, x, min, root->val - 1, _ownedFields);
    bstRemove(root->right, x, root->val + 1, max, _ownedFields);
  }
}

struct Node* create_tree(int val, struct OwnedFields* _ownedFields)
{
  struct Node* res = NULL;
  res = NULL;
  res = create_tree_helper(val, -2147483647, 2147483647, _ownedFields->instanceCounter);
  add_bst(res, -2147483647, 2147483647, _ownedFields);
  return res;
}

struct Node* create_tree_helper(int val, int min, int max, int* _instanceCounter)
{
  struct Node* root = NULL;
  root = NULL;
  root = alloc(struct Node);
  root->_id = *_instanceCounter;
  *_instanceCounter = *_instanceCounter + 1;
  root->val = val;
  root->left = NULL;
  root->right = NULL;
  return root;
}

int main()
{
  int stress = 0;
  int seed = 0;
  int stressCaptured = 0;
  struct Node* t1 = NULL;
  int i = 0;
  int j = 0;
  int r = 0;
  int toAdd = 0;
  bool test = false;
  int r1 = 0;
  int toRemove = 0;
  bool test1 = false;
  struct Node* t11 = NULL;
  struct Node* t12 = NULL;
  int* _instanceCounter = NULL;
  struct OwnedFields* _ownedFields = NULL;
  struct OwnedFields* _tempFields = NULL;
  struct OwnedFields* _tempFields1 = NULL;
  _instanceCounter = alloc(int);
  _ownedFields = initOwnedFields(_instanceCounter);
  stress = 0;
  seed = 0;
  stressCaptured = 0;
  t1 = NULL;
  i = 0;
  j = 0;
  r = 0;
  toAdd = 0;
  test = false;
  r1 = 0;
  toRemove = 0;
  test1 = false;
  t11 = NULL;
  t12 = NULL;
  stress = 0;
  seed = 1;
  stressCaptured = stress;
  if (stressCaptured / 2 * 2 != stressCaptured)
  {
    stressCaptured = stressCaptured + 1;
  }
  t1 = create_tree(stressCaptured, _ownedFields);
  i = 0;
  while (0 <= i && i < stressCaptured)
  {
    r = rand(seed);
    seed = r;
    toAdd = mod(r, 2 * stressCaptured);
    remove_tree(t1, _ownedFields);
    t11 = tree_add(t1, toAdd, _instanceCounter);
    add_tree(t11, _ownedFields);
    _tempFields = initOwnedFields(_instanceCounter);
    add_tree(t11, _tempFields);
    remove_tree(t11, _ownedFields);
    test = tree_contains(t11, toAdd, _tempFields);
    join(_ownedFields, _tempFields);
    assert(test);
    i = i + 1;
    t1 = t11;
  }
  j = 0;
  while (j < stressCaptured)
  {
    r1 = rand(seed);
    seed = r1;
    toRemove = mod(r1, 2 * stressCaptured);
    remove_tree(t1, _ownedFields);
    t12 = tree_remove(t1, toRemove, _instanceCounter);
    add_treeRemove(t12, toRemove, _ownedFields);
    remove_treeRemove(t12, toRemove, _ownedFields);
    tree_main_lemma(t12, toRemove, _instanceCounter);
    add_tree(t12, _ownedFields);
    _tempFields1 = initOwnedFields(_instanceCounter);
    add_tree(t12, _tempFields1);
    remove_tree(t12, _ownedFields);
    test1 = tree_contains(t12, toRemove, _tempFields1);
    join(_ownedFields, _tempFields1);
    assert(!test1);
    j = j + 1;
    t1 = t12;
  }
  return 0;
}

void remove_bst(struct Node* root, int min, int max, struct OwnedFields* _ownedFields)
{
  if (!(root == NULL))
  {
    loseAcc(_ownedFields, root->_id, 1);
    loseAcc(_ownedFields, root->_id, 2);
    loseAcc(_ownedFields, root->_id, 0);
    remove_bst(root->left, min, root->val - 1, _ownedFields);
    remove_bst(root->right, root->val + 1, max, _ownedFields);
  }
}

void remove_bstRemove(struct Node* root, int x, int min, int max, struct OwnedFields* _ownedFields)
{
  if (!(root == NULL))
  {
    loseAcc(_ownedFields, root->_id, 1);
    loseAcc(_ownedFields, root->_id, 2);
    loseAcc(_ownedFields, root->_id, 0);
    remove_bstRemove(root->left, x, min, root->val - 1, _ownedFields);
    remove_bstRemove(root->right, x, root->val + 1, max, _ownedFields);
  }
}

void remove_tree(struct Node* root, struct OwnedFields* _ownedFields)
{
  remove_bst(root, -2147483647, 2147483647, _ownedFields);
}

void remove_treeRemove(struct Node* root, int x, struct OwnedFields* _ownedFields)
{
  remove_bstRemove(root, x, -2147483647, 2147483647, _ownedFields);
}

void sep_bst(struct Node* root, int min, int max, struct OwnedFields* _ownedFields)
{
  if (!(root == NULL))
  {
    addAccEnsureSeparate(_ownedFields, root != NULL ? root->_id : -1, 1, 4, "Overlapping field permissions for struct Node.left");
    addAccEnsureSeparate(_ownedFields, root != NULL ? root->_id : -1, 2, 4, "Overlapping field permissions for struct Node.right");
    addAccEnsureSeparate(_ownedFields, root != NULL ? root->_id : -1, 0, 4, "Overlapping field permissions for struct Node.val");
    sep_bst(root->left, min, root->val - 1, _ownedFields);
    sep_bst(root->right, root->val + 1, max, _ownedFields);
  }
}

void sep_bstRemove(struct Node* root, int x, int min, int max, struct OwnedFields* _ownedFields)
{
  if (!(root == NULL))
  {
    addAccEnsureSeparate(_ownedFields, root != NULL ? root->_id : -1, 1, 4, "Overlapping field permissions for struct Node.left");
    addAccEnsureSeparate(_ownedFields, root != NULL ? root->_id : -1, 2, 4, "Overlapping field permissions for struct Node.right");
    addAccEnsureSeparate(_ownedFields, root != NULL ? root->_id : -1, 0, 4, "Overlapping field permissions for struct Node.val");
    sep_bstRemove(root->left, x, min, root->val - 1, _ownedFields);
    sep_bstRemove(root->right, x, root->val + 1, max, _ownedFields);
  }
}

struct Node* tree_add(struct Node* root, int x, int* _instanceCounter)
{
  struct Node* res = NULL;
  res = NULL;
  res = tree_add_helper(root, x, -2147483647, 2147483647, _instanceCounter);
  return res;
}

struct Node* tree_add_helper(struct Node* root, int x, int min, int max, int* _instanceCounter)
{
  struct Node* _ = NULL;
  int v = 0;
  struct Node* l = NULL;
  struct Node* r = NULL;
  struct Node* _1 = NULL;
  struct Node* _2 = NULL;
  struct Node* _3 = NULL;
  struct Node* _4 = NULL;
  _ = NULL;
  v = 0;
  l = NULL;
  r = NULL;
  _1 = NULL;
  _2 = NULL;
  _3 = NULL;
  _4 = NULL;
  if (root == NULL)
  {
    _ = create_tree_helper(x, min, max, _instanceCounter);
    return _;
  }
  else
  {
    v = root->val;
    l = root->left;
    r = root->right;
    if (x < v)
    {
      if (l != NULL)
      {
        _1 = tree_add_helper(l, x, min, v - 1, _instanceCounter);
        root->left = _1;
      }
      else
      {
        _2 = create_tree_helper(x, min, v - 1, _instanceCounter);
        root->left = _2;
      }
    }
    else
    {
      if (v < x)
      {
        if (r != NULL)
        {
          _3 = tree_add_helper(r, x, v + 1, max, _instanceCounter);
          root->right = _3;
        }
        else
        {
          _4 = create_tree_helper(x, v + 1, max, _instanceCounter);
          root->right = _4;
        }
      }
    }
    return root;
  }
}

bool tree_contains(struct Node* root, int x, struct OwnedFields* _ownedFields)
{
  bool res = false;
  res = false;
  remove_bst(root, -2147483647, 2147483647, _ownedFields);
  res = tree_contains_helper(root, x, -2147483647, 2147483647, _ownedFields->instanceCounter);
  add_bst(root, -2147483647, 2147483647, _ownedFields);
  return res;
}

bool tree_contains_helper(struct Node* root, int x, int min, int max, int* _instanceCounter)
{
  int v = 0;
  struct Node* l = NULL;
  struct Node* r = NULL;
  bool temp1 = false;
  bool temp2 = false;
  v = 0;
  l = NULL;
  r = NULL;
  temp1 = false;
  temp2 = false;
  if (root == NULL)
  {
    return false;
  }
  else
  {
    v = root->val;
    l = root->left;
    r = root->right;
    if (v == x)
    {
      return true;
    }
    else
    {
      if (x < v)
      {
        temp1 = tree_contains_helper(l, x, min, v - 1, _instanceCounter);
        return temp1;
      }
      else
      {
        temp2 = tree_contains_helper(r, x, v + 1, max, _instanceCounter);
        return temp2;
      }
    }
  }
}

void tree_main_lemma(struct Node* root, int x, int* _instanceCounter)
{
  tree_main_lemma_bst(root, x, -2147483647, 2147483647, _instanceCounter);
}

void tree_main_lemma_bst(struct Node* root, int x, int min, int max, int* _instanceCounter)
{
  if (root == NULL)
  {
  }
  else
  {
    tree_main_lemma_bst(root->left, x, min, root->val - 1, _instanceCounter);
    tree_main_lemma_bst(root->right, x, root->val + 1, max, _instanceCounter);
  }
}

int tree_max(struct Node* root, struct OwnedFields* _ownedFields)
{
  int res = 0;
  res = 0;
  remove_bst(root, -2147483647, 2147483647, _ownedFields);
  res = tree_max_helper(root, -2147483647, 2147483647, _ownedFields->instanceCounter);
  add_bst(root, -2147483647, res, _ownedFields);
  tree_max_lemma(root, 2147483647, -2147483647, res, _ownedFields);
  return res;
}

int tree_max_helper(struct Node* root, int min, int max, int* _instanceCounter)
{
  int v = 0;
  struct Node* r = NULL;
  int m = 0;
  v = 0;
  r = NULL;
  m = 0;
  v = root->val;
  r = root->right;
  if (r == NULL)
  {
    return v;
  }
  else
  {
    m = tree_max_helper(r, v + 1, max, _instanceCounter);
    return m;
  }
}

void tree_max_lemma(struct Node* root, int newMax, int min, int max, struct OwnedFields* _ownedFields)
{
  bool _cond_1 = false;
  bool _cond_2 = false;
  _cond_1 = root == NULL;
  if (root == NULL)
  {
  }
  else
  {
    _cond_2 = root == NULL;
    tree_max_lemma(root->right, newMax, root->val + 1, max, _ownedFields);
  }
  if (!_cond_1 && !_cond_2 && !(root == NULL) || !_cond_1 && !_cond_2 && !(root == NULL) || !_cond_1 && !_cond_2 && !(root == NULL) || !_cond_1 && !_cond_2 && !(root == NULL) || !_cond_1 && !_cond_2 && !(root == NULL))
  {
    assertAcc(_ownedFields, root != NULL ? root->_id : -1, 0, "Field access runtime check failed for struct Node.val");
  }
  if (!_cond_1 && !_cond_2 && !(root == NULL) || !_cond_1 && !_cond_2 && !(root == NULL))
  {
    assertAcc(_ownedFields, root != NULL ? root->_id : -1, 2, "Field access runtime check failed for struct Node.right");
    assertAcc(_ownedFields, root != NULL ? root->_id : -1, 1, "Field access runtime check failed for struct Node.left");
  }
  if (!_cond_1 && !_cond_2 && !(root == NULL))
  {
    assert(root->val >= min);
    assert(root->val <= newMax);
    bst(root->right, root->val + 1, newMax, _ownedFields);
    bst(root->left, min, root->val - 1, _ownedFields);
  }
}

int tree_min(struct Node* root, struct OwnedFields* _ownedFields)
{
  int res = 0;
  res = 0;
  res = tree_min_helper(root, -2147483647, 2147483647, _ownedFields);
  tree_min_lemma(root, -2147483647, res, 2147483647, _ownedFields);
  return res;
}

int tree_min_helper(struct Node* root, int min, int max, struct OwnedFields* _ownedFields)
{
  int v = 0;
  struct Node* l = NULL;
  int m = 0;
  bool _cond_1 = false;
  bool _cond_2 = false;
  bool _cond_3 = false;
  v = 0;
  l = NULL;
  m = 0;
  _cond_1 = root == NULL;
  v = root->val;
  l = root->left;
  _cond_2 = l == NULL;
  if (l == NULL)
  {
    return v;
  }
  else
  {
    m = tree_min_helper(l, min, v - 1, _ownedFields);
    if (!_cond_1 && !_cond_2)
    {
      assert(m <= v);
    }
    if (!_cond_1 && !_cond_2 && !(l == NULL) || !_cond_1 && !_cond_2 && !(l == NULL) || !_cond_1 && !_cond_2 && !(l == NULL) || !_cond_1 && !_cond_2 && !(l == NULL) || !_cond_1 && !_cond_2 && !(l == NULL))
    {
      assertAcc(_ownedFields, l != NULL ? l->_id : -1, 0, "Field access runtime check failed for struct Node.val");
    }
    if (!_cond_1 && !_cond_2 && !(l == NULL) || !_cond_1 && !_cond_2 && !(l == NULL))
    {
      assertAcc(_ownedFields, l != NULL ? l->_id : -1, 2, "Field access runtime check failed for struct Node.right");
      assertAcc(_ownedFields, l != NULL ? l->_id : -1, 1, "Field access runtime check failed for struct Node.left");
    }
    if (!_cond_1 && !_cond_2 && !(l == NULL))
    {
      assert(l->val >= m);
      assert(l->val <= v - 1);
      bst(l->right, l->val + 1, v - 1, _ownedFields);
      bst(l->left, m, l->val - 1, _ownedFields);
    }
    _cond_3 = l == NULL;
    if (!_cond_1 && !_cond_2 && !_cond_3 && !(root == NULL) || !_cond_1 && !_cond_2 && !_cond_3 && !(root == NULL) || !_cond_1 && !_cond_2 && !_cond_3 && !(root == NULL) || !_cond_1 && !_cond_2 && !_cond_3 && !(root == NULL) || !_cond_1 && !_cond_2 && !_cond_3 && !(root == NULL))
    {
      assertAcc(_ownedFields, root != NULL ? root->_id : -1, 0, "Field access runtime check failed for struct Node.val");
    }
    if (!_cond_1 && !_cond_2 && !_cond_3 && !(root == NULL) || !_cond_1 && !_cond_2 && !_cond_3 && !(root == NULL))
    {
      assertAcc(_ownedFields, root != NULL ? root->_id : -1, 2, "Field access runtime check failed for struct Node.right");
      assertAcc(_ownedFields, root != NULL ? root->_id : -1, 1, "Field access runtime check failed for struct Node.left");
    }
    if (!_cond_1 && !_cond_2 && !_cond_3 && !(root == NULL))
    {
      assert(root->val >= m);
      assert(root->val <= max);
      bst(root->right, root->val + 1, max, _ownedFields);
      bst(root->left, m, root->val - 1, _ownedFields);
    }
    return m;
  }
}

void tree_min_lemma(struct Node* root, int newMin, int min, int max, struct OwnedFields* _ownedFields)
{
  bool _cond_1 = false;
  bool _cond_2 = false;
  _cond_1 = root == NULL;
  if (root == NULL)
  {
  }
  else
  {
    _cond_2 = root == NULL;
    tree_min_lemma(root->left, newMin, min, root->val - 1, _ownedFields);
  }
  if (!_cond_1 && !_cond_2 && !(root == NULL) || !_cond_1 && !_cond_2 && !(root == NULL) || !_cond_1 && !_cond_2 && !(root == NULL) || !_cond_1 && !_cond_2 && !(root == NULL) || !_cond_1 && !_cond_2 && !(root == NULL))
  {
    assertAcc(_ownedFields, root != NULL ? root->_id : -1, 0, "Field access runtime check failed for struct Node.val");
  }
  if (!_cond_1 && !_cond_2 && !(root == NULL) || !_cond_1 && !_cond_2 && !(root == NULL))
  {
    assertAcc(_ownedFields, root != NULL ? root->_id : -1, 2, "Field access runtime check failed for struct Node.right");
    assertAcc(_ownedFields, root != NULL ? root->_id : -1, 1, "Field access runtime check failed for struct Node.left");
  }
  if (!_cond_1 && !_cond_2 && !(root == NULL))
  {
    assert(root->val >= newMin);
    assert(root->val <= max);
    bst(root->right, root->val + 1, max, _ownedFields);
    bst(root->left, newMin, root->val - 1, _ownedFields);
  }
}

struct Node* tree_remove(struct Node* root, int x, int* _instanceCounter)
{
  struct Node* res = NULL;
  res = NULL;
  res = tree_remove_helper(root, x, -2147483647, 2147483647, _instanceCounter);
  return res;
}

struct Node* tree_remove_helper(struct Node* root, int x, int min, int max, int* _instanceCounter)
{
  int v = 0;
  struct Node* l = NULL;
  struct Node* r = NULL;
  struct Node* _ = NULL;
  struct Node* _1 = NULL;
  int m = 0;
  struct Node* _2 = NULL;
  bool _cond_1 = false;
  bool _cond_2 = false;
  bool _cond_3 = false;
  bool _cond_4 = false;
  bool _cond_5 = false;
  bool _cond_6 = false;
  bool _cond_7 = false;
  bool _cond_8 = false;
  struct OwnedFields* _ownedFields = NULL;
  struct OwnedFields* _tempFields = NULL;
  _ownedFields = initOwnedFields(_instanceCounter);
  add_bst(root, min, max, _ownedFields);
  v = 0;
  l = NULL;
  r = NULL;
  _ = NULL;
  _1 = NULL;
  m = 0;
  _2 = NULL;
  _cond_1 = root == NULL;
  if (root == NULL)
  {
    return root;
  }
  else
  {
    _cond_2 = root == NULL;
    v = root->val;
    l = root->left;
    r = root->right;
    _cond_3 = x < v;
    if (x < v)
    {
      remove_bst(l, min, v - 1, _ownedFields);
      _ = tree_remove_helper(l, x, min, v - 1, _instanceCounter);
      add_bstRemove(_, x, min, v - 1, _ownedFields);
      root->left = _;
      remove_bst(r, v + 1, max, _ownedFields);
      tree_remove_lemma_right(r, x, v + 1, max, _instanceCounter);
      add_bstRemove(r, x, v + 1, max, _ownedFields);
      return root;
    }
    else
    {
      _cond_4 = v < x;
      if (v < x)
      {
        remove_bst(r, v + 1, max, _ownedFields);
        _1 = tree_remove_helper(r, x, v + 1, max, _instanceCounter);
        add_bstRemove(_1, x, v + 1, max, _ownedFields);
        root->right = _1;
        tree_remove_lemma_left(l, x, min, v - 1, _ownedFields);
        if (!_cond_1 && !_cond_2 && !_cond_3 && _cond_4 && !(root == NULL) || !_cond_1 && !_cond_2 && !_cond_3 && _cond_4 && !(root == NULL) || !_cond_1 && !_cond_2 && !_cond_3 && _cond_4 && !(root == NULL) || !_cond_1 && !_cond_2 && !_cond_3 && _cond_4 && !(root == NULL) || !_cond_1 && !_cond_2 && !_cond_3 && _cond_4 && !(root == NULL) || !_cond_1 && !_cond_2 && !_cond_3 && _cond_4 && !(root == NULL))
        {
          assertAcc(_ownedFields, root != NULL ? root->_id : -1, 0, "Field access runtime check failed for struct Node.val");
        }
        if (!_cond_1 && !_cond_2 && !_cond_3 && _cond_4 && !(root == NULL) || !_cond_1 && !_cond_2 && !_cond_3 && _cond_4 && !(root == NULL))
        {
          assertAcc(_ownedFields, root != NULL ? root->_id : -1, 2, "Field access runtime check failed for struct Node.right");
          assertAcc(_ownedFields, root != NULL ? root->_id : -1, 1, "Field access runtime check failed for struct Node.left");
        }
        if (!_cond_1 && !_cond_2 && !_cond_3 && _cond_4 && !(root == NULL))
        {
          assert(root->val >= min);
          assert(root->val <= max);
          assert(!(root->val == x));
          bstRemove(root->right, x, root->val + 1, max, _ownedFields);
          bstRemove(root->left, x, min, root->val - 1, _ownedFields);
        }
        return root;
      }
      else
      {
        _cond_5 = l == NULL;
        if (l == NULL)
        {
          if (r == NULL)
          {
            return NULL;
          }
          else
          {
            remove_bst(r, v + 1, max, _ownedFields);
            tree_remove_lemma_right(r, x, v + 1, max, _instanceCounter);
            add_bstRemove(r, x, v + 1, max, _ownedFields);
            tree_remove_lemma_min(r, x, min, v + 1, max, _ownedFields);
            return r;
          }
        }
        else
        {
          _cond_6 = r == NULL;
          if (r == NULL)
          {
            tree_remove_lemma_left(l, x, min, v - 1, _ownedFields);
            remove_bstRemove(l, x, min, v - 1, _ownedFields);
            tree_remove_lemma_max(l, x, max, min, v - 1, _instanceCounter);
            add_bstRemove(l, x, min, max, _ownedFields);
            return l;
          }
          else
          {
            remove_bst(l, min, v - 1, _ownedFields);
            m = tree_max_helper(l, min, v - 1, _instanceCounter);
            add_bst(l, min, m, _ownedFields);
            _cond_7 = l == NULL;
            _cond_8 = l == NULL;
            root->val = m;
            remove_bst(l, min, m, _ownedFields);
            _2 = tree_remove_helper(l, m, min, m, _instanceCounter);
            add_bstRemove(_2, m, min, m, _ownedFields);
            root->left = _2;
            remove_bstRemove(root->left, m, min, m, _ownedFields);
            tree_remove_lemma(root->left, min, m, _instanceCounter);
            add_bstRemove(root->left, m, min, m - 1, _ownedFields);
            tree_remove_lemma_left2(root->left, x, m, min, m - 1, _ownedFields);
            _tempFields = initOwnedFields(_instanceCounter);
            if (!_cond_1 && !_cond_2 && !_cond_3 && !_cond_4 && !_cond_5 && !_cond_6 && !_cond_7 && !_cond_8)
            {
              bst(r, v + 1, max, _ownedFields);
            }
            sep_bst(r, v + 1, max, _tempFields);
            remove_bst(r, v + 1, max, _ownedFields);
            tree_remove_lemma_right(r, x, v + 1, max, _instanceCounter);
            add_bstRemove(r, x, v + 1, max, _ownedFields);
            tree_remove_lemma_min(r, x, m + 1, v + 1, max, _ownedFields);
            if (!_cond_1 && !_cond_2 && !_cond_3 && !_cond_4 && !_cond_5 && !_cond_6 && !_cond_7 && !_cond_8 && !(root == NULL) || !_cond_1 && !_cond_2 && !_cond_3 && !_cond_4 && !_cond_5 && !_cond_6 && !_cond_7 && !_cond_8 && !(root == NULL) || !_cond_1 && !_cond_2 && !_cond_3 && !_cond_4 && !_cond_5 && !_cond_6 && !_cond_7 && !_cond_8 && !(root == NULL) || !_cond_1 && !_cond_2 && !_cond_3 && !_cond_4 && !_cond_5 && !_cond_6 && !_cond_7 && !_cond_8 && !(root == NULL) || !_cond_1 && !_cond_2 && !_cond_3 && !_cond_4 && !_cond_5 && !_cond_6 && !_cond_7 && !_cond_8 && !(root == NULL) || !_cond_1 && !_cond_2 && !_cond_3 && !_cond_4 && !_cond_5 && !_cond_6 && !_cond_7 && !_cond_8 && !(root == NULL))
            {
              assertAcc(_ownedFields, root != NULL ? root->_id : -1, 0, "Field access runtime check failed for struct Node.val");
            }
            if (!_cond_1 && !_cond_2 && !_cond_3 && !_cond_4 && !_cond_5 && !_cond_6 && !_cond_7 && !_cond_8 && !(root == NULL) || !_cond_1 && !_cond_2 && !_cond_3 && !_cond_4 && !_cond_5 && !_cond_6 && !_cond_7 && !_cond_8 && !(root == NULL))
            {
              assertAcc(_ownedFields, root != NULL ? root->_id : -1, 2, "Field access runtime check failed for struct Node.right");
              assertAcc(_ownedFields, root != NULL ? root->_id : -1, 1, "Field access runtime check failed for struct Node.left");
            }
            if (!_cond_1 && !_cond_2 && !_cond_3 && !_cond_4 && !_cond_5 && !_cond_6 && !_cond_7 && !_cond_8 && !(root == NULL))
            {
              assert(root->val >= min);
              assert(root->val <= max);
              assert(!(root->val == x));
              bstRemove(root->right, x, root->val + 1, max, _ownedFields);
              bstRemove(root->left, x, min, root->val - 1, _ownedFields);
            }
            return root;
          }
        }
      }
    }
  }
}

void tree_remove_lemma(struct Node* root, int min, int max, int* _instanceCounter)
{
  if (root == NULL)
  {
  }
  else
  {
    tree_remove_lemma(root->right, root->val + 1, max, _instanceCounter);
  }
}

void tree_remove_lemma_left(struct Node* l, int x, int min, int max, struct OwnedFields* _ownedFields)
{
  bool _cond_1 = false;
  bool _cond_2 = false;
  bool _cond_3 = false;
  bool _cond_4 = false;
  bool _cond_5 = false;
  struct OwnedFields* _tempFields = NULL;
  _cond_1 = l == NULL;
  if (l == NULL)
  {
  }
  else
  {
    _cond_2 = l == NULL;
    _cond_3 = !(l == NULL) && l->left == NULL;
    if (l->left == NULL)
    {
      tree_remove_lemma_left(l->right, x, l->val + 1, max, _ownedFields);
    }
    else
    {
      _cond_4 = !(l == NULL) && l->right == NULL;
      if (l->right == NULL)
      {
        tree_remove_lemma_left(l->left, x, min, l->val - 1, _ownedFields);
        if (!_cond_1 && !_cond_2 && !_cond_3 && _cond_4)
        {
          assertAcc(_ownedFields, l != NULL ? l->_id : -1, 2, "Field access runtime check failed for struct Node.right");
          assertAcc(_ownedFields, l != NULL ? l->_id : -1, 0, "Field access runtime check failed for struct Node.val");
        }
        if (!_cond_1 && !_cond_2 && !_cond_3 && _cond_4 && !(l->right == NULL) || !_cond_1 && !_cond_2 && !_cond_3 && _cond_4 && !(l->right == NULL) || !_cond_1 && !_cond_2 && !_cond_3 && _cond_4 && !(l->right == NULL) || !_cond_1 && !_cond_2 && !_cond_3 && _cond_4 && !(l->right == NULL) || !_cond_1 && !_cond_2 && !_cond_3 && _cond_4 && !(l->right == NULL) || !_cond_1 && !_cond_2 && !_cond_3 && _cond_4 && !(l->right == NULL))
        {
          assertAcc(_ownedFields, l->right != NULL ? l->right->_id : -1, 0, "Field access runtime check failed for struct Node.val");
        }
        if (!_cond_1 && !_cond_2 && !_cond_3 && _cond_4 && !(l->right == NULL) || !_cond_1 && !_cond_2 && !_cond_3 && _cond_4 && !(l->right == NULL))
        {
          assertAcc(_ownedFields, l->right != NULL ? l->right->_id : -1, 2, "Field access runtime check failed for struct Node.right");
          assertAcc(_ownedFields, l->right != NULL ? l->right->_id : -1, 1, "Field access runtime check failed for struct Node.left");
        }
        if (!_cond_1 && !_cond_2 && !_cond_3 && _cond_4 && !(l->right == NULL))
        {
          assert(l->right->val >= l->val + 1);
          assert(l->right->val <= max);
          assert(!(l->right->val == x));
          bstRemove(l->right->right, x, l->right->val + 1, max, _ownedFields);
          bstRemove(l->right->left, x, l->val + 1, l->right->val - 1, _ownedFields);
        }
        _cond_5 = !(l == NULL) && l->right == NULL;
      }
      else
      {
        tree_remove_lemma_left(l->right, x, l->val + 1, max, _ownedFields);
        _tempFields = initOwnedFields(_ownedFields->instanceCounter);
        if (!_cond_1 && !_cond_2 && !_cond_3 && !_cond_4)
        {
          assertAcc(_ownedFields, l != NULL ? l->_id : -1, 1, "Field access runtime check failed for struct Node.left");
          assertAcc(_ownedFields, l != NULL ? l->_id : -1, 0, "Field access runtime check failed for struct Node.val");
          assert(l->val - 1 < x);
          bst(l->left, min, l->val - 1, _ownedFields);
        }
        sep_bst(l->left, min, l->val - 1, _tempFields);
        tree_remove_lemma_left(l->left, x, min, l->val - 1, _ownedFields);
      }
    }
  }
  if (!_cond_1 && !_cond_2 && !_cond_3 && !_cond_4 && !(l == NULL) || !_cond_1 && !_cond_2 && !_cond_3 && !_cond_4 && !(l == NULL) || !_cond_1 && !_cond_2 && !_cond_3 && !_cond_4 && !(l == NULL) || !_cond_1 && !_cond_2 && !_cond_3 && !_cond_4 && !(l == NULL) || !_cond_1 && !_cond_2 && !_cond_3 && !_cond_4 && !(l == NULL) || !_cond_1 && !_cond_2 && !_cond_3 && !_cond_4 && !(l == NULL) || !_cond_1 && !_cond_2 && !_cond_3 && _cond_4 && !_cond_5 && !(l == NULL) || !_cond_1 && !_cond_2 && !_cond_3 && _cond_4 && !_cond_5 && !(l == NULL) || !_cond_1 && !_cond_2 && !_cond_3 && _cond_4 && !_cond_5 && !(l == NULL) || !_cond_1 && !_cond_2 && !_cond_3 && _cond_4 && !_cond_5 && !(l == NULL) || !_cond_1 && !_cond_2 && !_cond_3 && _cond_4 && !_cond_5 && !(l == NULL) || !_cond_1 && !_cond_2 && !_cond_3 && _cond_4 && !_cond_5 && !(l == NULL) || !_cond_1 && !_cond_2 && _cond_3 && !(l == NULL) || !_cond_1 && !_cond_2 && _cond_3 && !(l == NULL) || !_cond_1 && !_cond_2 && _cond_3 && !(l == NULL) || !_cond_1 && !_cond_2 && _cond_3 && !(l == NULL) || !_cond_1 && !_cond_2 && _cond_3 && !(l == NULL) || !_cond_1 && !_cond_2 && _cond_3 && !(l == NULL))
  {
    assertAcc(_ownedFields, l != NULL ? l->_id : -1, 0, "Field access runtime check failed for struct Node.val");
  }
  if (!_cond_1 && !_cond_2 && !_cond_3 && !_cond_4 && !(l == NULL) || !_cond_1 && !_cond_2 && !_cond_3 && !_cond_4 && !(l == NULL) || !_cond_1 && !_cond_2 && !_cond_3 && _cond_4 && !_cond_5 && !(l == NULL) || !_cond_1 && !_cond_2 && !_cond_3 && _cond_4 && !_cond_5 && !(l == NULL) || !_cond_1 && !_cond_2 && _cond_3 && !(l == NULL) || !_cond_1 && !_cond_2 && _cond_3 && !(l == NULL))
  {
    assertAcc(_ownedFields, l != NULL ? l->_id : -1, 2, "Field access runtime check failed for struct Node.right");
  }
  if (!_cond_1 && !_cond_2 && !_cond_3 && !_cond_4 && !(l == NULL) || !_cond_1 && !_cond_2 && !_cond_3 && !_cond_4 && !(l == NULL) || !_cond_1 && !_cond_2 && !_cond_3 && _cond_4 && !_cond_5 && !(l == NULL) || !_cond_1 && !_cond_2 && !_cond_3 && _cond_4 && !_cond_5 && !(l == NULL) || !_cond_1 && !_cond_2 && !_cond_3 && _cond_4 && _cond_5 && !(l == NULL) || !_cond_1 && !_cond_2 && !_cond_3 && _cond_4 && _cond_5 && !(l == NULL) || !_cond_1 && !_cond_2 && _cond_3 && !(l == NULL) || !_cond_1 && !_cond_2 && _cond_3 && !(l == NULL))
  {
    assertAcc(_ownedFields, l != NULL ? l->_id : -1, 1, "Field access runtime check failed for struct Node.left");
  }
  if (!_cond_1 && !_cond_2 && !_cond_3 && !_cond_4 && !(l == NULL) || !_cond_1 && !_cond_2 && !_cond_3 && _cond_4 && !_cond_5 && !(l == NULL) || !_cond_1 && !_cond_2 && !_cond_3 && _cond_4 && _cond_5 && !(l == NULL) || !_cond_1 && !_cond_2 && _cond_3 && !(l == NULL))
  {
    assert(l->val >= min);
    assert(l->val <= max);
    bstRemove(l->right, x, l->val + 1, max, _ownedFields);
    bstRemove(l->left, x, min, l->val - 1, _ownedFields);
  }
  if (!_cond_1 && !_cond_2 && !_cond_3 && !_cond_4 && !(l == NULL) || !_cond_1 && !_cond_2 && !_cond_3 && _cond_4 && !_cond_5 && !(l == NULL) || !_cond_1 && !_cond_2 && _cond_3 && !(l == NULL))
  {
    assert(!(l->val == x));
  }
}

void tree_remove_lemma_left2(struct Node* l, int newX, int x, int min, int max, struct OwnedFields* _ownedFields)
{
  bool _cond_1 = false;
  bool _cond_2 = false;
  bool _cond_3 = false;
  bool _cond_4 = false;
  bool _cond_5 = false;
  struct OwnedFields* _tempFields = NULL;
  _cond_1 = l == NULL;
  if (l == NULL)
  {
  }
  else
  {
    _cond_2 = l == NULL;
    _cond_3 = !(l == NULL) && l->left == NULL;
    if (l->left == NULL)
    {
      tree_remove_lemma_left2(l->right, newX, x, l->val + 1, max, _ownedFields);
      if (!_cond_1 && !_cond_2 && _cond_3)
      {
        assertAcc(_ownedFields, l != NULL ? l->_id : -1, 1, "Field access runtime check failed for struct Node.left");
        assertAcc(_ownedFields, l != NULL ? l->_id : -1, 0, "Field access runtime check failed for struct Node.val");
      }
      if (!_cond_1 && !_cond_2 && _cond_3 && !(l->left == NULL) || !_cond_1 && !_cond_2 && _cond_3 && !(l->left == NULL) || !_cond_1 && !_cond_2 && _cond_3 && !(l->left == NULL) || !_cond_1 && !_cond_2 && _cond_3 && !(l->left == NULL) || !_cond_1 && !_cond_2 && _cond_3 && !(l->left == NULL) || !_cond_1 && !_cond_2 && _cond_3 && !(l->left == NULL))
      {
        assertAcc(_ownedFields, l->left != NULL ? l->left->_id : -1, 0, "Field access runtime check failed for struct Node.val");
      }
      if (!_cond_1 && !_cond_2 && _cond_3 && !(l->left == NULL) || !_cond_1 && !_cond_2 && _cond_3 && !(l->left == NULL))
      {
        assertAcc(_ownedFields, l->left != NULL ? l->left->_id : -1, 2, "Field access runtime check failed for struct Node.right");
        assertAcc(_ownedFields, l->left != NULL ? l->left->_id : -1, 1, "Field access runtime check failed for struct Node.left");
      }
      if (!_cond_1 && !_cond_2 && _cond_3 && !(l->left == NULL))
      {
        assert(l->left->val >= min);
        assert(l->left->val <= l->val - 1);
        assert(!(l->left->val == newX));
        bstRemove(l->left->right, newX, l->left->val + 1, l->val - 1, _ownedFields);
        bstRemove(l->left->left, newX, min, l->left->val - 1, _ownedFields);
      }
      _cond_5 = !(l == NULL) && l->left == NULL;
    }
    else
    {
      _cond_4 = !(l == NULL) && l->right == NULL;
      if (l->right == NULL)
      {
        tree_remove_lemma_left2(l->left, newX, x, min, l->val - 1, _ownedFields);
      }
      else
      {
        tree_remove_lemma_left2(l->right, newX, x, l->val + 1, max, _ownedFields);
        _tempFields = initOwnedFields(_ownedFields->instanceCounter);
        if (!_cond_1 && !_cond_2 && !_cond_3 && !_cond_4)
        {
          assertAcc(_ownedFields, l != NULL ? l->_id : -1, 1, "Field access runtime check failed for struct Node.left");
          assertAcc(_ownedFields, l != NULL ? l->_id : -1, 0, "Field access runtime check failed for struct Node.val");
          assert(l->val - 1 < newX);
          bstRemove(l->left, x, min, l->val - 1, _ownedFields);
        }
        sep_bstRemove(l->left, x, min, l->val - 1, _tempFields);
        tree_remove_lemma_left2(l->left, newX, x, min, l->val - 1, _ownedFields);
      }
    }
  }
  if (!_cond_1 && !_cond_2 && !_cond_3 && !_cond_4 && !(l == NULL) || !_cond_1 && !_cond_2 && !_cond_3 && !_cond_4 && !(l == NULL) || !_cond_1 && !_cond_2 && !_cond_3 && !_cond_4 && !(l == NULL) || !_cond_1 && !_cond_2 && !_cond_3 && !_cond_4 && !(l == NULL) || !_cond_1 && !_cond_2 && !_cond_3 && !_cond_4 && !(l == NULL) || !_cond_1 && !_cond_2 && !_cond_3 && !_cond_4 && !(l == NULL) || !_cond_1 && !_cond_2 && !_cond_3 && _cond_4 && !(l == NULL) || !_cond_1 && !_cond_2 && !_cond_3 && _cond_4 && !(l == NULL) || !_cond_1 && !_cond_2 && !_cond_3 && _cond_4 && !(l == NULL) || !_cond_1 && !_cond_2 && !_cond_3 && _cond_4 && !(l == NULL) || !_cond_1 && !_cond_2 && !_cond_3 && _cond_4 && !(l == NULL) || !_cond_1 && !_cond_2 && !_cond_3 && _cond_4 && !(l == NULL) || !_cond_1 && !_cond_2 && _cond_3 && !_cond_5 && !(l == NULL) || !_cond_1 && !_cond_2 && _cond_3 && !_cond_5 && !(l == NULL) || !_cond_1 && !_cond_2 && _cond_3 && !_cond_5 && !(l == NULL) || !_cond_1 && !_cond_2 && _cond_3 && !_cond_5 && !(l == NULL) || !_cond_1 && !_cond_2 && _cond_3 && !_cond_5 && !(l == NULL) || !_cond_1 && !_cond_2 && _cond_3 && !_cond_5 && !(l == NULL))
  {
    assertAcc(_ownedFields, l != NULL ? l->_id : -1, 0, "Field access runtime check failed for struct Node.val");
  }
  if (!_cond_1 && !_cond_2 && !_cond_3 && !_cond_4 && !(l == NULL) || !_cond_1 && !_cond_2 && !_cond_3 && !_cond_4 && !(l == NULL) || !_cond_1 && !_cond_2 && !_cond_3 && _cond_4 && !(l == NULL) || !_cond_1 && !_cond_2 && !_cond_3 && _cond_4 && !(l == NULL) || !_cond_1 && !_cond_2 && _cond_3 && !_cond_5 && !(l == NULL) || !_cond_1 && !_cond_2 && _cond_3 && !_cond_5 && !(l == NULL) || !_cond_1 && !_cond_2 && _cond_3 && _cond_5 && !(l == NULL) || !_cond_1 && !_cond_2 && _cond_3 && _cond_5 && !(l == NULL))
  {
    assertAcc(_ownedFields, l != NULL ? l->_id : -1, 2, "Field access runtime check failed for struct Node.right");
  }
  if (!_cond_1 && !_cond_2 && !_cond_3 && !_cond_4 && !(l == NULL) || !_cond_1 && !_cond_2 && !_cond_3 && !_cond_4 && !(l == NULL) || !_cond_1 && !_cond_2 && !_cond_3 && _cond_4 && !(l == NULL) || !_cond_1 && !_cond_2 && !_cond_3 && _cond_4 && !(l == NULL) || !_cond_1 && !_cond_2 && _cond_3 && !_cond_5 && !(l == NULL) || !_cond_1 && !_cond_2 && _cond_3 && !_cond_5 && !(l == NULL))
  {
    assertAcc(_ownedFields, l != NULL ? l->_id : -1, 1, "Field access runtime check failed for struct Node.left");
  }
  if (!_cond_1 && !_cond_2 && !_cond_3 && !_cond_4 && !(l == NULL) || !_cond_1 && !_cond_2 && !_cond_3 && _cond_4 && !(l == NULL) || !_cond_1 && !_cond_2 && _cond_3 && !_cond_5 && !(l == NULL) || !_cond_1 && !_cond_2 && _cond_3 && _cond_5 && !(l == NULL))
  {
    assert(l->val >= min);
    assert(l->val <= max);
    bstRemove(l->right, newX, l->val + 1, max, _ownedFields);
    bstRemove(l->left, newX, min, l->val - 1, _ownedFields);
  }
  if (!_cond_1 && !_cond_2 && !_cond_3 && !_cond_4 && !(l == NULL) || !_cond_1 && !_cond_2 && !_cond_3 && _cond_4 && !(l == NULL) || !_cond_1 && !_cond_2 && _cond_3 && !_cond_5 && !(l == NULL))
  {
    assert(!(l->val == newX));
  }
}

void tree_remove_lemma_max(struct Node* root, int x, int newMax, int min, int max, int* _instanceCounter)
{
  if (root == NULL)
  {
  }
  else
  {
    tree_remove_lemma_max(root->right, x, newMax, root->val + 1, max, _instanceCounter);
  }
}

void tree_remove_lemma_min(struct Node* root, int x, int newMin, int min, int max, struct OwnedFields* _ownedFields)
{
  bool _cond_1 = false;
  bool _cond_2 = false;
  _cond_1 = root == NULL;
  if (root == NULL)
  {
  }
  else
  {
    _cond_2 = root == NULL;
    tree_remove_lemma_min(root->left, x, newMin, min, root->val - 1, _ownedFields);
  }
  if (!_cond_1 && !_cond_2 && !(root == NULL) || !_cond_1 && !_cond_2 && !(root == NULL) || !_cond_1 && !_cond_2 && !(root == NULL) || !_cond_1 && !_cond_2 && !(root == NULL) || !_cond_1 && !_cond_2 && !(root == NULL) || !_cond_1 && !_cond_2 && !(root == NULL))
  {
    assertAcc(_ownedFields, root != NULL ? root->_id : -1, 0, "Field access runtime check failed for struct Node.val");
  }
  if (!_cond_1 && !_cond_2 && !(root == NULL) || !_cond_1 && !_cond_2 && !(root == NULL))
  {
    assertAcc(_ownedFields, root != NULL ? root->_id : -1, 2, "Field access runtime check failed for struct Node.right");
    assertAcc(_ownedFields, root != NULL ? root->_id : -1, 1, "Field access runtime check failed for struct Node.left");
  }
  if (!_cond_1 && !_cond_2 && !(root == NULL))
  {
    assert(root->val >= newMin);
    assert(root->val <= max);
    assert(!(root->val == x));
    bstRemove(root->right, x, root->val + 1, max, _ownedFields);
    bstRemove(root->left, x, newMin, root->val - 1, _ownedFields);
  }
}

void tree_remove_lemma_right(struct Node* r, int x, int min, int max, int* _instanceCounter)
{
  if (r == NULL)
  {
  }
  else
  {
    if (r->left == NULL)
    {
      tree_remove_lemma_right(r->right, x, r->val + 1, max, _instanceCounter);
    }
    else
    {
      if (r->right == NULL)
      {
        tree_remove_lemma_right(r->left, x, min, r->val - 1, _instanceCounter);
      }
      else
      {
        tree_remove_lemma_right(r->right, x, r->val + 1, max, _instanceCounter);
        tree_remove_lemma_right(r->left, x, min, r->val - 1, _instanceCounter);
      }
    }
  }
}
